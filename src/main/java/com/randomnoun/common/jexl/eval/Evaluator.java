package com.randomnoun.common.jexl.eval;

/* (c) 2013 randomnoun. All Rights Reserved. This work is licensed under a
 * BSD Simplified License. (http://www.randomnoun.com/bsd-simplified.html)
 */

import java.math.BigDecimal;
import java.text.*; // for SimpleDateFormat & friends
import java.util.*;



import org.apache.log4j.Logger;

import com.randomnoun.common.Text;
import com.randomnoun.common.jexl.ast.*;
import com.randomnoun.common.jexl.visitor.*;


/**
 * This class traverses (and evaluates) an expression AST graph. It
 * traverses the AST in depth-first order (by extending the ObjectDepthFirst
 * visitor class generated by jtb). This class implements the
 * 'Visitor' design pattern.
 *
 * <p>Each visit() method in this class takes two parameters, the
 * first being the node being visited, and the second contains
 * an EvalContext object containing the variables and functions which can
 * be referenced within the expression. The visitor (i.e. this class) is then
 * passed to it's children nodes using the nodes' accept() method (generated
 * by jtb).
 *
 * <p>Variables can be any wrappered primitive type (e.g. Long, Integer, ...),
 * although mathematical evaluation (+, -, /, etc) are currently only
 * implemented for Doubles and Longs.
 *
 * <p>This class can be considered thread-safe, since it holds no instance-wide state.
 * (All methods that require access to a EvalContext have it passed in through a
 * method parameter). i.e. many threads may use the same Evaluator instance to
 * evaluate different expressions.
 *
 * <p>NB: In the javadocs below, "lhs" refers to the left-hand-side value of any binary
 * operation, and "rhs" refers to the right-hand-side value; e.g. in "3 + 4",
 * the lhs is "3", the rhs is "4" and the op is "+".
 * 
 * @author knoxg
 */
public class Evaluator
    extends GJDepthFirst<Object, EvalContext> {

    // We used to create a variable with this name before executing any function calls 
	// containing the Evaluator instance that is being used to evaluate the function. Not entirely sure why any more, so have commented it out.
    // public static final String VAR_EVALUATOR = ".evaluator";


    /** Logger instance for this class */
    Logger logger = Logger.getLogger(Evaluator.class);

    // could probably use generics these days
    // and I'm pretty sure these are in java.util.functions as well
    
    /** Binary operation interface; takes two parameters, returns a result. */
    interface BinaryOp {
        Object op(Object a, Object b);
    }

    /** A binary operation on two parameters whose types are guaranteed to be Long. */
    abstract class LongOp implements BinaryOp {
        public Object op(Object a, Object b) {
            long longA = ((Long) a).longValue();
            long longB = (b == null ? 0 : ((Long) b).longValue());
            return new Long(longOp(longA, longB));
        }
        abstract long longOp(long a, long b);
    }

    /** A binary operation on two parameters whose types are guaranteed to be Double. */
    abstract class DoubleOp implements BinaryOp {
        public Object op(Object a, Object b) {
            double doubleA = ((Double) a).doubleValue();
            double doubleB = (b == null ? 0 : ((Double) b).doubleValue());
            return new Double(doubleOp(doubleA, doubleB));
        }
        abstract double doubleOp(double a, double b);
    }

    /** Coerce parameter 'b' into a compatible type of parameter 'a', to be used in a
     *  binary math op. If 'b' can't be coerced into 'a', then throw an EvalException.
     *
     * @param a First binary op parameter (the type of which we are casting to)
     * @param b Second binary op parameter (the value we are casting)
     * @return The value of 'b', coerced to be the same type of value 'a'
     */
    public Object coerceType(Object a, Object b) {
    	// don't coerce nulls
    	if (a == null) { return null; }

        Class<? extends Object> clazz = a.getClass();
        if (b == null || clazz.isInstance(b)) { return b; }

        if (a instanceof Date) {
            if (b instanceof String) {
                // convert string to date
                DateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
                try {
                    return sdf.parse((String) b);
                } catch (java.text.ParseException pe) {
                    throw new EvalException("Could not parse date '" + b + "': " + pe.getMessage());
                }
            }
        }

        if (a instanceof Double) {
            if (b instanceof Number) {
                return new Double(((Number) b).doubleValue());
            }
        }

        if (a instanceof Long) {
            if (b instanceof Number) {
                return new Long(((Number) b).longValue());
            }
        }

		if (a instanceof BigDecimal) {
			if (b instanceof Number) {
				// not sure if this keeps enough precision, but good enough for testing 
				return new BigDecimal(((Number) b).toString());  
			}
		}

        throw new EvalException("cannot coerce " + b.getClass().getName() + " to " + clazz.getName());
    }

    /** Binary math operation. Takes two parameters, the name of the op (only used in
     * exception text), and BinaryOp classes for all supported types. (We only
     * support math operations on Longs and Doubles at the moment, should be easy to
     * add new types if required). If we were aiming for completeness, I'd implement
     * Short, Int, Byte, Char, BigInteger and BigDecimal.
     *
     * <p>The rhs of the expression is coerced into the type of the lhs.
     *
     * @param a lhs parameter
     * @param b rhs parameter
     * @param op name of op
     * @param longOp operation to perform if lhs is Long
     * @param doubleOp operation to perform if lhs in Double
     * @return the evaluated result of the op
     */
    public Object mathOp(Object a, Object b, String op, BinaryOp longOp, BinaryOp doubleOp) {
        b = coerceType(a, b);

        if (a instanceof Long) {
            return longOp.op(a, b);
        } else if (a instanceof Double) {
            return doubleOp.op(a, b);
        }

        throw new EvalException("'" + op + "' can only operator on numeric types (found '" + a + "' of type " + a.getClass().getName() + ")");
    }

    /** Evaluate a TopLevelExpression node. The PRE text in this javadoc corresponds to
     * the javacc expansion of this node; e.g. in expression.jj, the rule for TopLevelExpression
     * is
     *
     * <pre>
     * void TopLevelExpression():
     * {}
     * {
     *   Expression() <EOF>
     * }
     * </pre>
     *
     * <p>jtb then creates two fields in the TopLevelExpression object, "expression" (containing
     * the Expression() node) and "nodeToken" (containing the EOF token). This is documented
     * in the form below (this is included for all jtb-generated visit methods):
     *
     * <PRE>
     * expression -> Expression()
     * nodeToken -> &lt;EOF&gt;
     * </PRE>
     */
    public Object visit(TopLevelExpression n, EvalContext context) {
        return n.expression.accept(this, context);
    }

    /** Evaluate an Expression node.
     *
     * <PRE>
     * conditionalAndExpression -> ConditionalAndExpression()
     * nodeListOptional -> ( "||" ConditionalAndExpression() )*
     * </PRE>
     */
    public Object visit(Expression n, EvalContext context) {
        NodeSequence seq;
        Object lhs;
        Object rhs;

        lhs = n.conditionalAndExpression.accept(this, context);

        for (Enumeration<Node> e = n.nodeListOptional.elements(); e.hasMoreElements();) {
            seq = (NodeSequence) e.nextElement();
            rhs = seq.elementAt(1).accept(this, context);

            if (!(lhs instanceof Boolean)) {
                throw new EvalException("lhs must be boolean");
            }

            if (!(rhs instanceof Boolean)) {
                throw new EvalException("rhs must be boolean");
            }

            // NB: performs short-cut evaluation 
            boolean result = ((Boolean) lhs).booleanValue() || ((Boolean) rhs).booleanValue();

            lhs = Boolean.valueOf(result);
        }

        return lhs;
    }

    /** Evaluate a ConditionalAndExpression node.
     *
     * <PRE>
     * equalityExpression -> EqualityExpression()
     * nodeListOptional -> ( "&&" EqualityExpression() )*
     * </PRE>
     */
    public Object visit(ConditionalAndExpression n, EvalContext context) {
        NodeSequence seq;
        Object lhs;
        Object rhs;

        lhs = n.equalityExpression.accept(this, context);

        for (Enumeration<Node> e = n.nodeListOptional.elements(); e.hasMoreElements();) {
            seq = (NodeSequence) e.nextElement();
            rhs = seq.elementAt(1).accept(this, context);
            rhs = coerceType(lhs, rhs);

            if (!(lhs instanceof Boolean)) {
                throw new EvalException("lhs must be boolean");
            }

            if (!(rhs instanceof Boolean)) {
                throw new EvalException("rhs must be boolean");
            }

            // NB: performs short-cut evaluation 
            boolean result = ((Boolean) lhs).booleanValue() && ((Boolean) rhs).booleanValue();

            lhs = Boolean.valueOf(result);
        }

        return lhs;
    }

    /** Evaluate a EqualityExpression node.
     *
     * <PRE>
     * relationalExpression -> RelationalExpression()
     * nodeListOptional -> ( ( "==" | "!=" ) RelationalExpression() )*
     * </PRE>
     */
    @SuppressWarnings("unchecked")
	public Object visit(EqualityExpression n, EvalContext context) {
        NodeSequence seq;
        Object lhs;
        Object rhs;
        // String[] ops = { "==", "!=" };

        lhs = n.relationalExpression.accept(this, context);

        for (Enumeration<Node> e = n.nodeListOptional.elements(); e.hasMoreElements();) {
            seq = (NodeSequence) e.nextElement();
            rhs = seq.elementAt(1).accept(this, context);
            rhs = coerceType(lhs, rhs);

            if (!(lhs==null || lhs instanceof Comparable)) {
                throw new EvalException("Cannot compare lhs");
            }

            if (!(rhs==null || rhs instanceof Comparable)) {
                // this may not be required (only lhs needs to be comparable to run .compareTo)
                throw new EvalException("Cannot compare rhs");
            }

            int which = ((NodeChoice) seq.elementAt(0)).which;
            
            // this may throw an IllegalStateException if they're not comparable after all
            int result = -1;
            try {
            	// perform null checks first (allow nulls in either lhs or rhs of equality check)
            	if (lhs==null) {
            		return (which==0) ? Boolean.valueOf(rhs==null) : Boolean.valueOf(rhs!=null);
            	} else if (rhs==null) {
					return (which==0) ? Boolean.valueOf(lhs==null) : Boolean.valueOf(lhs!=null);
            	}
                result = ((Comparable<Object>) lhs).compareTo(rhs);
            } catch (IllegalStateException ise) {
                throw (EvalException) new EvalException("Cannot perform evaluation").initCause(ise);
            }

            // logger.debug("Running op '" + ops[which] + "' on lhs:" + lhs + ", rhs:" + rhs);
            switch (which) {
                case 0: lhs = new Boolean(result == 0); break;
                case 1: lhs = new Boolean(result != 0); break;
                default:
                    throw new EvalException("Internal error - unexpected relational operation");
            }
        }

        return lhs;
    }

    /** Evaluate a RelationalExpression node.
     *
     * <PRE>
     * additiveExpression -> AdditiveExpression()
     * nodeListOptional -> ( ( "&lt;" | "&gt;" | "&lt;=" | "&gt;=" ) AdditiveExpression() )*
     * </PRE>
     */
    @SuppressWarnings("unchecked")
	public Object visit(RelationalExpression n, EvalContext context) {
        NodeSequence seq;
        Object lhs;
        Object rhs;
        // String[] ops = { "<", ">", "<=", ">=" };

        lhs = n.additiveExpression.accept(this, context);

        for (Enumeration<Node> e = n.nodeListOptional.elements(); e.hasMoreElements();) {
            seq = (NodeSequence) e.nextElement();
            rhs = seq.elementAt(1).accept(this, context);
            rhs = coerceType(lhs, rhs);

            if (!(lhs instanceof Comparable)) {
                throw new EvalException("Cannot compare lhs (found type '" + lhs.getClass().getName() + "')");
            }

            if (!(rhs instanceof Comparable)) {
                // this may not be required (only lhs needs to be comparable to run .compareTo)
                throw new EvalException("Cannot compare rhs");
            }

            int which = ((NodeChoice) seq.elementAt(0)).which;
            int result = -1;
            try {
                result = ((Comparable<Object>) lhs).compareTo(rhs);
            } catch (IllegalStateException ise) {
                throw (EvalException) new EvalException("Cannot perform evaluation").initCause(ise);
            }

            // logger.debug("Running op '" + ops[which] + "' on lhs:" + lhs + ", rhs:" + rhs);
            switch (which) {
                case 0: lhs = new Boolean(result < 0); break;
                case 1: lhs = new Boolean(result > 0); break;
                case 2: lhs = new Boolean(result <= 0); break;
                case 3: lhs = new Boolean(result >= 0); break;
                default:
                    throw new EvalException("Internal error - unexpected relational operation");
            }
        }

        return lhs;
    }

    /** Evaluate a AdditiveExpression node.
     *
     * <PRE>
     * multiplicativeExpression -> MultiplicativeExpression()
     * nodeListOptional -> ( ( "+" | "-" ) MultiplicativeExpression() )*
     * </PRE>
     */
    public Object visit(AdditiveExpression n, EvalContext context) {
        NodeSequence seq;
        Object lhs;
        Object rhs;
        // String[] ops = { "+", "-" };

        lhs = n.multiplicativeExpression.accept(this, context);

        for (Enumeration<Node> e = n.nodeListOptional.elements(); e.hasMoreElements();) {
            seq = (NodeSequence) e.nextElement();
            rhs = seq.elementAt(1).accept(this, context);

            int which = ((NodeChoice) seq.elementAt(0)).which;

            // logger.debug("Running op '" + ops[which] + "' on lhs:" + lhs + ", rhs:" + rhs);
            switch (which) {
                case 0:
                    if (lhs instanceof String) {
                        // String addition
                        lhs = ((String) lhs) + rhs.toString();
                    } else {
                        // Numeric addition
                        lhs = mathOp(lhs, rhs, "+", 
                          new LongOp() { public long longOp(long a, long b) { return a + b; } }, 
                          new DoubleOp() { public double doubleOp(double a, double b) { return a + b; } });
                    }
                    break;
                case 1:
                    lhs = mathOp(lhs, rhs, "-", 
                      new LongOp() { public long longOp(long a, long b) { return a - b; } }, 
                      new DoubleOp() { public double doubleOp(double a, double b) { return a - b; } });
                    break;
                default:
                    throw new EvalException("Internal error - unexpected additive operation");
            }
        }

        return lhs;
    }

    /** Evaluate a MultiplicativeExpression node.
     *
     * <PRE>
     * unaryExpression -> UnaryExpression()
     * nodeListOptional -> ( ( "*" | "/" | "%" ) UnaryExpression() )*
     * </PRE>
     */
    public Object visit(MultiplicativeExpression n, EvalContext context) {
        NodeSequence seq;
        Object lhs;
        Object rhs;
        // String[] ops = { "*", "/", "%" };

        lhs = n.unaryExpression.accept(this, context);

        for (Enumeration<Node> e = n.nodeListOptional.elements(); e.hasMoreElements();) {
            seq = (NodeSequence) e.nextElement();
            rhs = seq.elementAt(1).accept(this, context);

            int which = ((NodeChoice) seq.elementAt(0)).which;

            // logger.debug("Running op '" + ops[which] + "' on lhs:" + lhs + ", rhs:" + rhs);
            switch (which) {
                case 0:
                    lhs = mathOp(lhs, rhs, "*", 
                      new LongOp() { public long longOp(long a, long b) { return a * b; } }, 
                      new DoubleOp() { public double doubleOp(double a, double b) { return a * b; } });
                    break;
                case 1:
                    lhs = mathOp(lhs, rhs, "/", 
                      new LongOp() { public long longOp(long a, long b) { return a / b; } }, 
                      new DoubleOp() { public double doubleOp(double a, double b) { return a / b; } });
                    break;
                case 2:
                    lhs = mathOp(lhs, rhs, "%", 
                      new LongOp() { public long longOp(long a, long b) { return a % b; } }, 
                      new DoubleOp() { public double doubleOp(double a, double b) { return a % b; } });
                    break;
                default:
                    throw new EvalException("Internal error - unexpected additive operation");
            }
        }

        return lhs;
    }

    /** Evaluate a UnaryExpression node.
     *
     * <PRE>
     * nodeChoice -> ( "~" | "!" | "-" ) UnaryExpression()
     *       | PrimaryExpression()
     * </PRE>
     */
    public Object visit(UnaryExpression n, EvalContext context) {
        NodeSequence seq;
        Object lhs;

        if (n.nodeChoice.which == 0) {
            seq = (NodeSequence) n.nodeChoice.choice;

            int which = ((NodeChoice) seq.elementAt(0)).which;

            // String op = ((NodeToken) ((NodeChoice) nl.nodes.get(0)).choice).tokenImage;
            switch (which) {
                case 0:
                    // long rhs =  makeNumeric ( ((Node) nl.nodes.get(0)).accept(this, context) ); 
                    // return new Long(~rhs); 
                    throw new EvalException("~ not supported");
                case 1:
                    lhs = seq.elementAt(1).accept(this, context);
                    if (!(lhs instanceof Boolean)) {
                        throw new EvalException("boolean type expected");
                    }
                    return Boolean.valueOf(!((Boolean) lhs).booleanValue());
                case 2:
                    lhs = seq.elementAt(1).accept(this, context);
                    if (!(lhs instanceof Number)) {
                        throw new EvalException("numeric type expected");
                    }
                    return mathOp(lhs, null, "-", new 
                      LongOp() { public long longOp(long a, long b) { return -a; } }, 
                      new DoubleOp() { public double doubleOp(double a, double b) { return -a; } } );
                default:
                    throw new EvalException("Internal error - unexpected unary operation");
            }
        } else {
            return n.nodeChoice.choice.accept(this, context);
        }
    }

    /** Evaluate a PrimaryExpression node.
     *
     * <PRE>
     * nodeChoice -> FunctionCall()
     *       | Name()
     *       | Literal()
     *       | "(" Expression() ")"
     * </PRE>
     */
    public Object visit(PrimaryExpression n, EvalContext context) {
        NodeSequence seq;
        int which = n.nodeChoice.which;

        switch (which) {
            case 0:
            case 1:
            case 2:
                return n.nodeChoice.choice.accept(this, context);
            case 3:
                seq = (NodeSequence) n.nodeChoice.choice;
                Object obj = seq.elementAt(1).accept(this, context);

                ;

                return obj;
            default:
                throw new EvalException("Internal parser error (PrimaryExpression)");
        }
    }

    /** Evaluate a Name node.
     *
     * <PRE>
     * nodeToken -> &lt;IDENTIFIER&gt;
     * nodeListOptional -> ( "." &lt;IDENTIFIER&gt; )*
     * </PRE>
     */
    public Object visit(Name n, EvalContext context) {
        EvalContext evalContext = (EvalContext) context;
        String varComponentName;
        String varBaseName = n.nodeToken.tokenImage;

        // logger.debug("Fetching var '" + varBaseName + "'");
        if (evalContext == null) {
            throw new EvalException("Cannot retrieve variable '" + varBaseName + "' with a null evalContext");
        }

        if (!evalContext.hasVariable(varBaseName)) {
            throw new EvalException("Unknown variable '" + varBaseName + "'");
        }

        Object value = evalContext.getVariable(varBaseName);
        NodeSequence seq;

        /*
           if (value == null) {
               logger.debug(" = null");
           } else {
               logger.debug(" = " + value.getClass().getName() + " with value '" + value + "'");
           }
         */
        for (Enumeration<Node> e = n.nodeListOptional.elements(); e.hasMoreElements();) {
            seq = (NodeSequence) e.nextElement();
            varComponentName = ((NodeToken) seq.elementAt(1)).tokenImage;

            //logger.debug("Fetching component '" + varComponentName + "' from var '" + varBaseName + "'");
            if (!evalContext.hasVariableComponent(value, varBaseName, varComponentName)) {
                throw new EvalException("Unknown variable component '" + varComponentName + "' in variable '" + varBaseName + "'");
            }

            value = evalContext.getVariableComponent(value, varBaseName, varComponentName);
            varBaseName = varBaseName + "." + varComponentName;
        }

        return value;
    }

    /** Evaluate a FunctionCall node.
     *
     * <PRE>
     * nodeToken -> &lt;IDENTIFIER&gt;
     * arguments -> Arguments()
     * </PRE>
     */
    public Object visit(FunctionCall n, EvalContext context) {
        @SuppressWarnings("unchecked")
		List<Object> argumentList = (List<Object>) n.arguments.accept(this, context);
        String functionName = n.nodeToken.tokenImage;
        EvalContext evalContext = (EvalContext) context;
        EvalFunction function = (EvalFunction) evalContext.getFunction(functionName);
        if (function == null) {
            throw new EvalException("Unknown function '" + functionName + "'");
        }
        /*
        if (evalContext.getVariable(VAR_EVALUATOR) != null) {
            evalContext.setVariable(VAR_EVALUATOR, this);
        }
        */
        return function.evaluate(functionName, evalContext, argumentList);
    }

    /** Evaluates an Arguments node
     *
     * <PRE>
     * nodeToken -> "("
     * nodeOptional -> [ ArgumentList() ]
     * nodeToken1 -> ")"
     * </PRE>
     */
    public Object visit(Arguments n, EvalContext context) {
        if (n.nodeOptional.present()) {
            return n.nodeOptional.accept(this, context);
        } else {
            return new ArrayList<Object>(0);
        }
    }

    /** Evaluate a ArgumentList node.
     *
     * <PRE>
     * expression -> Expression()
     * nodeListOptional -> ( "," Expression() )*
     * </PRE>
     */
    public Object visit(ArgumentList n, EvalContext context) {
        NodeSequence seq;
        List<Object> arguments = new ArrayList<Object>();

        arguments.add(n.expression.accept(this, context));

        for (Enumeration<Node> e = n.nodeListOptional.elements(); e.hasMoreElements();) {
            seq = (NodeSequence) e.nextElement();
            arguments.add(seq.elementAt(1).accept(this, context));
        }

        return arguments;
    }

    /** Evaluate a Literal node.
     *
     * <PRE>
     * nodeChoice -> &lt;INTEGER_LITERAL&gt;
     *       | &lt;FLOATING_POINT_LITERAL&gt;
     *       | &lt;CHARACTER_LITERAL&gt;
     *       | &lt;STRING_LITERAL&gt;
     *       | BooleanLiteral()
     *       | NullLiteral()
     * </PRE>
     *
     */
    public Object visit(Literal n, EvalContext context) {
        String token = null;

        if (n.nodeChoice.choice instanceof NodeToken) {
            token = ((NodeToken) n.nodeChoice.choice).tokenImage;
        }

        switch (n.nodeChoice.which) {
            case 0:
                return new Long(token);
            case 1:
                return new Double(token);
            case 2:
                return new Character(token.charAt(1));
            case 3:
                return Text.unescapeJava(token.substring(1, token.length() - 1));
        }

        // must be 'true', 'false', or 'null'
        return n.nodeChoice.accept(this, context);
    }

    /** Evaluate a BooleanLiteral node.
     *
     * <PRE>
     * nodeChoice -> "true"
     *       | "false"
     * </PRE>
     */
    public Object visit(BooleanLiteral n, EvalContext context) {
        if (n.nodeChoice.which == 0) {
            return Boolean.valueOf(true);
        } else {
            return Boolean.valueOf(false);
        }
    }

    /** Evaluate a NullLiteral node.
     *
     * <PRE>
     * nodeToken -> "null"
     * </PRE>
     */
    public Object visit(NullLiteral n, EvalContext context) {
        return null;
    }

    /** This is never executed (we do not evaluate tokens) */
    public Object visit(NodeToken n, EvalContext context) {
        return n.tokenImage;
    }
}
